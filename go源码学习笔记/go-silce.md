## 数组和切片

slice 的底层数据是数组，是对数组结构的封装，它描述了一个数组的片段，两者都可以通过下标来访问单个元素。

数组是定长的，长度定义好之后不能更改，在 Go 中，数组不太常见，因为长度定长限制了它的表达能力。而切片更加灵活可以动态扩容，切片的类型和长度无关的。

数组就是一片连续的内存， slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。

```go
type slice struct {
    array unsafe.Pointer // 元素指针
    len int //长度
    cap int //容量
}
```
slice 底层结构如下
![](https://golang.design/go-questions/slice/assets/0.png)

注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。

> 【引申1】 [3]int 和 [4]int 是同一个类型吗？
不是。因为数组的长度是类型的一部分，这是与 slice 不同的一点。

## 切片容量是如何增长的
般都是在向 slice 追加了元素之后，才会引起扩容。追加元素调用的是 append 函数。

先来看看 append 函数的原型：

```c
func append(slice []Type, elems ...Type) []Type
```

append 函数的参数长度可变，因此可以追加多个值到 slice 中，还可以用 ... 传入 slice，直接追加一个切片。
使用 append 可以向 slice 添加元素，实际上是往底层数组添加元素，但是底层数组长度是固定的，如果索引 len-1 所指向的元素已经是底层数组的最后一个元素的话，就没法添加了。
这时候 slice 会迁移到新的内存位置，新底层数据长度也会增加，这样就可以放置新增元素，同时为了应对未来可能的情况，新的底层数组长度和 slice 的容量是留了一定的 buffer 的。否则，每次添加元素的时候，都会发生迁移，成本太高。

新 slice 预留的 buffer 大小是有一定规律的。

### 扩容规则

在golang1.18版本更新之前网上大多数的文章都是这样描述slice的扩容策略的：
- 当原 slice 的容量小于 1024 时，扩容后的容量是原容量的 2 倍。
- 当原 slice 的容量大于或等于 1024 时，扩容后的容量是原容量的 1.25 倍。
- 注意： 1024 是指 元素的数量
这种策略是为了在小容量时快速扩展，而在大容量时避免过度分配内存。

在 Go 1.18 之后，扩容策略变得更加平滑：
- 当原容量小于 256 时，扩容为原来的 2 倍。
- 当原容量大于或等于 256 时，扩容公式为：newcap += (newcap + 3 * threshold) / 4；其中 threshold 是 256。这个公式使得扩容系数从 2 平滑过渡到 1.25，避免了扩容系数的突变。
